## 基础知识
> Redis 有16个数据库, 默认使用第0个。

```shell
127.0.0.1:6379> select 3          ## 切换数据库
OK
127.0.0.1:6379[3]> DBSIZE         ## 查看数据库大小
(integer) 0
127.0.0.1:6379[3]> SET name fuck
OK
127.0.0.1:6379[3]> KEYS *         ## 查看所有的key
1) "name"
127.0.0.1:6379[3]> FLUSHDB        ## 清空当前数据库
OK
127.0.0.1:6379[3]> KEYS *
(empty array)
127.0.0.1:6379[3]> FLUSHALL       ## 清空全部数据库
OK
127.0.0.1:6379> move name 1       ## 删除
(integer) 1
127.0.0.1:6379> EXISTS name       ## 判断是否存在
(integer) 0
127.0.0.1:6379> EXPIRE name 5     ## 设置数据的过期时间
(integer) 1
127.0.0.1:6379> ttl name          ## 查看剩余的过期时间
127.0.0.1:6379> TYPE name         ## 查看数据类型
string
```

> Redis 是单线程的!

Redis是很快的，官方表示，Redis是基于内存的操作，CPU并不是Redis的性能瓶颈，Redis的瓶颈是根据机器的内存和网络带宽，既然可以使用单线程来实现，就使用单线程了！

Redis 是 C 语言写的，官方提供的数据为 100000+ QPS，完全不比同样是使用key-value的Memecache差！

> Redis 为什么单线程还这么快？

核心: Redis 是将所有的数据全部放在内存中的，所以说使用单线程效率就是最高的，多线程会存在CPU上下文切换，反而耗时。对于内存系统来说，如果没有上下文切换，那么效率就是最高的！

# 五大数据类型
## String（字符串）

```shell
###################################################################################
127.0.0.1:6379> SET key1 v1
OK
127.0.0.1:6379> GET key1
"v1"
127.0.0.1:6379> APPEND key1 "hello"           ## 追加,如果不存在就相当于set key
(integer) 7
127.0.0.1:6379> GET key1
"v1hello"
127.0.0.1:6379> STRLEN key1                   ## 获取长度
(integer) 7
###################################################################################
127.0.0.1:6379> SET views 1
OK
127.0.0.1:6379> GET views
"1"
127.0.0.1:6379> INCR views                ## views++
(integer) 2
127.0.0.1:6379> INCR views
(integer) 3
127.0.0.1:6379> INCRBY views 5            ## views+=5
(integer) 8
127.0.0.1:6379> DECR views                ## views--
(integer) 7
127.0.0.1:6379> DECRBY views 3            ## views-=3
(integer) 4
127.0.0.1:6379> GET views
"4"
###################################################################################
127.0.0.1:6379> SET key1 "what the fuck!"
OK
127.0.0.1:6379> GET key1
"what the fuck!"
127.0.0.1:6379> GETRANGE key1 0 3         ## 截取 [0,3]
"what"
127.0.0.1:6379> GETRANGE key1 0 -1        ## 截取全部字符串
"what the fuck!"
127.0.0.1:6379> SETRANGE key1 9 shit      ## 从第9个字符开始替换
(integer) 14
127.0.0.1:6379> GET key1
"what the shit!"
###################################################################################
# setex(set with expire)   # 设置过期时间
# setnx(set if not exist)  # 不存在则设置
127.0.0.1:6379> setex key3 30 "hello"
OK
127.0.0.1:6379> TTL key3
(integer) 25
127.0.0.1:6379> GET key3
"hello"
127.0.0.1:6379> KEYS *
1) "key3"
2) "mykey"
3) "key1"
127.0.0.1:6379> TTL key3
(integer) -2
127.0.0.1:6379> KEYS *
1) "mykey"
2) "key1"
127.0.0.1:6379> SETNX mykey "MongoDB"    ## mykey已经存在, 0:表示设置失败
(integer) 0
127.0.0.1:6379> GET MYKEY
"redis"
###################################################################################
127.0.0.1:6379> MSET k1 v1 k2 v2           ## 批量设置多个值
OK
127.0.0.1:6379> MGET k1 k2                 ## 批量获取多个值
1) "v1"
2) "v2"
127.0.0.1:6379> MSETNX k1 v1 k3 v3
(integer) 0
127.0.0.1:6379> GET k3                     ## MSETNX是原子操作
(nil)

# 这里的key是一个巧妙的设计:  user:{id}:{age}
127.0.0.1:6379> mset user:1:name fuck user:1:age 20
OK
127.0.0.1:6379> mget user:1:name user:1:age
1) "fuck"
2) "20"
###################################################################################
# getset 先 get 在 set
127.0.0.1:6379> GETSET db redis          ## 如果不存在就返回nil，并设置新的值
(nil)
127.0.0.1:6379> GET db
"redis"
127.0.0.1:6379> GETSET db mongodb        ## 如果存在，就返回原来的值，并设置新的值
"redis"
127.0.0.1:6379> GET db
"mongodb"
###################################################################################
```

## List
> 本质上是一个链表

```shell
###################################################################################
127.0.0.1:6379> LPUSH list one          ## 头插
(integer) 1
127.0.0.1:6379> LPUSH list two
(integer) 2
127.0.0.1:6379> LPUSH list three
(integer) 3
127.0.0.1:6379> RPUSH list right        ## 尾插
(integer) 4
127.0.0.1:6379> LRANGE list 0 -1
1) "three"
2) "two"
3) "one"
4) "right"
127.0.0.1:6379> LPOP list               ## 头删
"three"
127.0.0.1:6379> RPOP list               ## 尾删
"right"
###################################################################################
127.0.0.1:6379> LRANGE list 0 -1
1) "two"
2) "one"
127.0.0.1:6379> LINDEX list 0           ## 获取对应下标的值
"two"
###################################################################################
127.0.0.1:6379> LLEN list               ## 获取长度
(integer) 2
###################################################################################
127.0.0.1:6379> LPUSH list one
(integer) 3
127.0.0.1:6379> LRANGE list 0 -1
1) "one"
2) "two"
3) "one"
127.0.0.1:6379> LREM list 2 one             ## 删除两个 "one", 根据value来删除
(integer) 2
127.0.0.1:6379> LRANGE list 0 -1
1) "two"
###################################################################################
127.0.0.1:6379> RPUSH list 1
(integer) 2
127.0.0.1:6379> RPUSH list 2
(integer) 3
127.0.0.1:6379> RPUSH list 3
(integer) 4
127.0.0.1:6379> LRANGE list 0 -1
1) "two"
2) "1"
3) "2"
4) "3"
127.0.0.1:6379> LTRIM list 1 2              ## 截断 [1,2]
OK
127.0.0.1:6379> LRANGE list 0 -1
1) "1"
2) "2"
###################################################################################
127.0.0.1:6379> LRANGE list 0 -1
1) "1"
2) "2"
127.0.0.1:6379> RPOPLPUSH list list2        ## 从list的右侧删除，添加到list2的左侧
"2"
127.0.0.1:6379> LRANGE list 0 -1
1) "1"
127.0.0.1:6379> LRANGE list2 0 -1
1) "2"
###################################################################################
127.0.0.1:6379> LSET list 0 10000           ## 更改指定下表对应的值
OK
127.0.0.1:6379> lrange list 0 0
1) "10000"
127.0.0.1:6379> lset list 1 10000           ## 超出范围，报错
(error) ERR index out of range
###################################################################################
127.0.0.1:6379> LRANGE list 0 -1
1) "10000"
127.0.0.1:6379> LINSERT list BEFORE 10000 hello    ## 在指定value前插入
(integer) 2
127.0.0.1:6379> LINSERT list AFTER 10000 world     ## 在指定value后插入
(integer) 3
127.0.0.1:6379> lrange list 0 -1
1) "hello"
2) "10000"
3) "world"
###################################################################################
```

## Set
> Set 中的值不能重复

```shell
###################################################################################
127.0.0.1:6379> SADD myset "hello"                ## 添加
(integer) 1
127.0.0.1:6379> SADD myset "world"
(integer) 1
127.0.0.1:6379> SADD myset "the"
(integer) 1
127.0.0.1:6379> SMEMBERS myset                    ## 查看所有
1) "hello"
2) "world"
3) "the"
127.0.0.1:6379> SISMEMBER myset hello             ## 判断是否存在
(integer) 1
127.0.0.1:6379> SISMEMBER myset fuck
(integer) 0
###################################################################################
127.0.0.1:6379> SCARD myset                       ## 查看元素个数
(integer) 3
127.0.0.1:6379> SREM myset the                    ## 移除指定元素
(integer) 1
127.0.0.1:6379> SMEMBERS myset
1) "hello"
2) "world"
###################################################################################
127.0.0.1:6379> SMEMBERS myset
1) "hello"
2) "world"
127.0.0.1:6379> SRANDMEMBER myset                 ## 无序不重复集合,抽随机(1个)
"world"
127.0.0.1:6379> SRANDMEMBER myset
"world"
127.0.0.1:6379> SRANDMEMBER myset
"hello"
127.0.0.1:6379> SRANDMEMBER myset 2               ## 2个
"hello"
###################################################################################
127.0.0.1:6379> spop myset                        ## 随机移除
"world"
127.0.0.1:6379> SMEMBERS myset
1) "hello"
###################################################################################
127.0.0.1:6379> sadd myset hello
(integer) 1
127.0.0.1:6379> sadd myset world
(integer) 1
127.0.0.1:6379> sadd myset the
(integer) 1
127.0.0.1:6379> sadd myset2 set2
(integer) 1
127.0.0.1:6379> smove myset myset2 the           ## 移动制定的元素
(integer) 1
127.0.0.1:6379> SMEMBERS myset
1) "hello"
2) "world"
127.0.0.1:6379> SMEMBERS myset2
1) "set2"
2) "the"
###################################################################################
127.0.0.1:6379> SADD myset a b c
(integer) 0
127.0.0.1:6379> SADD myset2 c d e
(integer) 3
127.0.0.1:6379> SDIFF myset myset2               ## 差集
1) "b"
2) "a"
127.0.0.1:6379> SDIFF myset2 myset
1) "d"
2) "e"
127.0.0.1:6379> SINTER myset myset2              ## 交集
1) "c"
127.0.0.1:6379> SUNION myset myset2              ## 并集
1) "a"
2) "c"
3) "e"
4) "d"
5) "b"
###################################################################################
```

## Hash
> Hash 更适合于对象的存储，String 更适合字符串的存储！

```shell
###################################################################################
127.0.0.1:6379> hset myhash field1 fuck                  ## 设置值
(integer) 1
127.0.0.1:6379> hget myhash field2                       ## 获取值
(nil)
127.0.0.1:6379> hget myhash field1
"fuck"
127.0.0.1:6379> hmset myhash field1 hello field2 world   ## 批量设置
OK
127.0.0.1:6379> hmget myhash field1 field2               ## 批量获取
1) "hello"
2) "world"
127.0.0.1:6379> hgetall myhash                           ## 获取所有值
1) "field1"
2) "hello"
3) "field2"
4) "world"
127.0.0.1:6379> hdel myhash field1                       ## 删除
(integer) 1
###################################################################################
127.0.0.1:6379> hlen myhash                              ## 获取长度
(integer) 1
127.0.0.1:6379> HEXISTS myhash field2                    ## 判断key是否存在
(integer) 1
###################################################################################
127.0.0.1:6379> hkeys myhash                             ## 获取所有的key
1) "field2"
127.0.0.1:6379> hvals myhash                             ## 获取所有的value
1) "world"
###################################################################################
```

## Zset(有序集合)

> 在 set 的基础上，增加了一个值，zset k1 score v1

```shell
###################################################################################
127.0.0.1:6379> ZADD myset 1 one                       ## 添加
(integer) 1
127.0.0.1:6379> ZADD myset 2 two
(integer) 1
127.0.0.1:6379> ZADD myset 3 three
(integer) 1
127.0.0.1:6379> ZRANGE myset 0 -1                      ## 查看所有元素
1) "one"
2) "two"
3) "three"
###################################################################################
127.0.0.1:6379> ZADD salary 2000 xiaohong
(integer) 1
127.0.0.1:6379> ZADD salary 5000 xiaozhang
(integer) 1
127.0.0.1:6379> ZADD salary 1000 xiaowang
(integer) 1
127.0.0.1:6379> ZRANGEBYSCORE salary -inf +inf       ## 升序排序, 范围[-inf,+inf]
1) "xiaowang"
2) "xiaohong"
3) "xiaozhang"
127.0.0.1:6379> ZREVRANGEBYSCORE salary +inf -inf    ## 降序排序
1) "xiaozhang"
2) "xiaohong"
3) "xiaowang"
127.0.0.1:6379> ZRANGEBYSCORE salary -inf +inf withscores    ## 升序,附带score
1) "xiaowang"
2) "1000"
3) "xiaohong"
4) "2000"
5) "xiaozhang"
6) "5000"
127.0.0.1:6379> ZRANGEBYSCORE salary -inf 2500 withscores    ## [-inf,2500]
1) "xiaowang"
2) "1000"
3) "xiaohong"
4) "2000"
127.0.0.1:6379> ZCOUNT salary 1000 3000                      ## 获取薪水在指定区间的成员数量
(integer) 2
###################################################################################
127.0.0.1:6379> ZRANGE myset 0 -1
1) "one"
2) "two"
3) "three"
127.0.0.1:6379> ZREM myset three                     ## 移除元素
(integer) 1
127.0.0.1:6379> ZRANGE myset 0 -1
1) "one"
2) "two"
127.0.0.1:6379> ZCARD myset                          ## 获取元素个数
(integer) 2
###################################################################################
```

# 三种特殊数据类型
## Geospatial 地理位置
> 推算地址位置的信息，两地之间的距离
>
> 底层的实现原理, 其实就是Zset！我们可以使用Zset命令来操作GEO
>
> http://www.jsons.cn/lngcode/

```shell
###################################################################################
# GEOADD 添加地理位置
127.0.0.1:6379> GEOADD china:city 16.405285 39.904989 beijing     ## 添加地理位置
(integer) 1
127.0.0.1:6379> GEOADD china:city 121.472644 31.231706 shanghai
(integer) 1
127.0.0.1:6379> GEOADD china:city 106.504962 29.533155 chongqing
(integer) 1
127.0.0.1:6379> GEOADD china:city 113.93029 22.53291 shenzhen 120.16922 30.24255 hangzhou
(integer) 2
127.0.0.1:6379> GEOADD china:city 109.21417 34.36665 xian
(integer) 1
###################################################################################
# GEOPOS 获得当前的定位，是一个作标值!
127.0.0.1:6379> GEOPOS china:city beijing
1) 1) "16.40528351068496704"
   2) "39.9049884229125027"
127.0.0.1:6379> GEOPOS china:city beijing chongqing
1) 1) "16.40528351068496704"
   2) "39.9049884229125027"
2) 1) "106.50495976209640503"
   2) "29.53315530684997015"
###################################################################################
# GEODIST 获取两个给定位置之间的距离
127.0.0.1:6379> GEODIST china:city beijing shanghai
"8972677.9326"
127.0.0.1:6379> GEODIST china:city beijing shanghai km
"8972.6779"
###################################################################################
# GEORADIUS 以给定的经纬度为中心，找出某一半径内的元素
127.0.0.1:6379> GEOPOS china:city beijing
1) 1) "16.40528351068496704"
   2) "39.9049884229125027"
127.0.0.1:6379> GEORADIUS china:city 16 39 1000 km
1) "beijing"
127.0.0.1:6379> GEORADIUS china:city 16 39 10000 km
1) "beijing"
2) "chongqing"
3) "xian"
4) "shenzhen"
5) "hangzhou"
6) "shanghai"
127.0.0.1:6379> GEORADIUS china:city 16 39 10000 km withdist
1) 1) "beijing"
   2) "106.5063"
2) 1) "chongqing"
   2) "8040.2107"
3) 1) "xian"
   2) "7939.4303"
4) 1) "shenzhen"
   2) "9101.5345"
5) 1) "hangzhou"
   2) "9033.9319"
6) 1) "shanghai"
   2) "9057.1212"
###################################################################################
# GEORADIUSBYMEMBER 找出位于指定元素周围的其它元素
127.0.0.1:6379> GEORADIUSBYMEMBER china:city beijing 1000 km
1) "beijing"
127.0.0.1:6379> GEORADIUSBYMEMBER china:city beijing 10000 km
1) "beijing"
2) "chongqing"
3) "xian"
4) "shenzhen"
5) "hangzhou"
6) "shanghai"
###################################################################################
# 使用Zset命令来操作GEO
127.0.0.1:6379> ZRANGE china:city 0 -1
1) "beijing"
2) "chongqing"
3) "xian"
4) "shenzhen"
5) "hangzhou"
6) "shanghai"
127.0.0.1:6379> ZREM china:city beijing
(integer) 1
```

## Hyperloglog
> 基数统计算法

```shell
127.0.0.1:6379> PFADD mykey a b c d e f
(integer) 1
127.0.0.1:6379> PFADD mykey1 d e f g h i h
(integer) 1
127.0.0.1:6379> PFADD mykey1 d e f g h i
(integer) 0
127.0.0.1:6379> FLUSHALL
OK
127.0.0.1:6379> PFADD mykey a b c d e f
(integer) 1
127.0.0.1:6379> PFADD mykey1 d e f g h i
(integer) 1
127.0.0.1:6379> PFCOUNT mykey
(integer) 6
127.0.0.1:6379> PFCOUNT mykey1
(integer) 6
127.0.0.1:6379> PFMERGE mykey3 mykey mykey1
OK
127.0.0.1:6379> PFCOUNT mykey3
(integer) 9
```

## Bitmaps
```shell
127.0.0.1:6379> SETBIT sign 0 1
(integer) 0
127.0.0.1:6379> SETBIT sign 1 0
(integer) 0
127.0.0.1:6379> SETBIT sign 2 1
(integer) 0
127.0.0.1:6379> GETBIT sign 2
(integer) 1
127.0.0.1:6379> BITCOUNT sign     ## 为1的数量
(integer) 2
```

## 事务
> Redis 单条命令保证原子性,但是事务不保证原子性!
>
> Redis 事务没有隔离级别的概念!
>
> Redis 事务的本质：一组命令的集合! 一个事务中的所有命令都会被序列化，在事务执行的过程中，会按照顺序执行!
>
> 一次性，顺序性，排它性！执行一系列的命令！

Redis 的事务:
- 开启事务(multi)
- 命令入队(...)
- 执行事务(exec)

```shell
127.0.0.1:6379> MULTI          ## 开启事务
OK
127.0.0.1:6379> SET k1 v1
QUEUED
127.0.0.1:6379> SET k2 v2
QUEUED
127.0.0.1:6379> GET k2
QUEUED
127.0.0.1:6379> EXEC           ## 开始执行
1) OK
2) OK
3) "v2"
127.0.0.1:6379> MULTI
OK
127.0.0.1:6379> SET k4 v4
QUEUED
127.0.0.1:6379> DISCARD        ## 取消事务
OK
127.0.0.1:6379> GET k4
(nil)
```

> 命令有错（编译错误），事务中的所有命令都不会被执行！

```redis
127.0.0.1:6379> MULTI
OK
127.0.0.1:6379> SET k1 v1
QUEUED
127.0.0.1:6379> SET k2
(error) ERR wrong number of arguments for 'set' command
127.0.0.1:6379> SET k3 v3
QUEUED
127.0.0.1:6379> EXEC
(error) EXECABORT Transaction discarded because of previous errors.
127.0.0.1:6379> GET k1
(nil)
```

> 运行时错误，如果事务队列中存在语法错误，其它命令可以被正常执行！

```redis
127.0.0.1:6379> MULTI
OK
127.0.0.1:6379> set k1 v1
QUEUED
127.0.0.1:6379> INCR k1
QUEUED
127.0.0.1:6379> EXEC
1) OK
2) (error) ERR value is not an integer or out of range
127.0.0.1:6379> GET k1
"v1"
```

> 监控！WATCH

**悲观锁**
- 很悲观，无论做什么都要进行加锁！

**乐观锁**
- 很乐观，不会上锁，只有在更新数据的时候去判断一下，在此期间是否有人修改过这个数据！


> 正常执行成功

```shell
127.0.0.1:6379> SET money 100
OK
127.0.0.1:6379> SET out 0
OK
127.0.0.1:6379> WATCH money           ## 监视 money 对象
OK
127.0.0.1:6379> MULTI                 ## 事务正常结束，因为在事务执行期间money没有被变动过!
OK
127.0.0.1:6379> DECRBY money 20
QUEUED
127.0.0.1:6379> INCRBY out 20
QUEUED
127.0.0.1:6379> EXEC
1) (integer) 80
2) (integer) 20
```

> 不正常执行失败（多线程）

```shell
## 线程1
127.0.0.1:6379> SET money 100
OK
127.0.0.1:6379> SET out 0
OK
127.0.0.1:6379> WATCH money
OK
127.0.0.1:6379> MULTI
OK
127.0.0.1:6379> DECRBY money 20
QUEUED
127.0.0.1:6379> INCRBY out 20       ## 在线程1执行EXEC命令前线程2先一步执行操作
QUEUED
127.0.0.1:6379> EXEC                ## 执行失败，因为money发生了变化
(nil)

## 线程2
127.0.0.1:6379> GET money
"100"
127.0.0.1:6379> MULTI
OK
127.0.0.1:6379> EXEC
(empty array)
127.0.0.1:6379> SET money 10000
OK
```
