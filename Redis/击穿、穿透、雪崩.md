### 1. 击穿（热点key、高并发）

**产生原因**

```shell
一个key非常热点，在不停的扛着高并发，高并发集中对这一个点进行访问。
在这个key失效的瞬间，持续的高并发穿破缓存，请求抵达数据库，就像在一个屏幕上凿开了一个洞。
```

**解决方案**

```shell
1. 设置热点数据永不过期
2. 保证只有一个线程去数据库取数据，剩余线程等待并从redis中获取数据。这种方式将高并发的压力转移到了`分布式锁`，因此对分布式锁的考验很大。
```



### 2. 穿透（数据未命中）

**产生原因**

```shell
用户查询一条数据，redis未命中，转向查询数据库，依旧未命中，成为了一条无效查询，高并发下会导致缓存穿透！
```

**解决方案**

```shell
布隆过滤器：对所有可能查询的参数以hash形式存储，在控制层先进行校验，不符合则丢弃，从而避免了对底层存储系统的查询压力！
```



### 3. 雪崩（大量key失效）

 **产生原因**

```shell
缓存雪崩，是指在某一个时间段，缓存集中过期失效。所有请求都转向数据库，给数据库造成巨大压力。

比如：在双十一零点的时候，来了一波抢购，这波商品时间比较集中的放入了缓存，假设缓存一个小时，那么到了凌晨一点的时候，这批商品的缓存都过期了，而对这批商品的访问查询都落到了数据库上，对于数据库而言，就会产生周期性的压力波峰。于是所有的请求都会达到存储层，存储层的调用量会暴增，造成存储层也会挂掉的情况。
```

**解决方案**

```shell
- 时点性无关，随机过期时间
- 时点性相关（某一个时间点前后的数据不同）
	1. 强依赖击穿方案（分布式锁确定一个线程访问数据库）
	2. 对时点到达的请求进行延迟（例：30ms），先到达的和后到达的请求可能存在一致性问题
```

